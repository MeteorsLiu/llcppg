This document provides a high-level overview of the official llpkgs generation process & usage.

# Definition

## LLpkg

Generated by a toolchain from an _upstream_. An LLpkg essentially represents a collection of bindings for C/C++ dynamic libraries in Go, allowing them to be used like native Go functions.

## Upstream

The provider of binary libraries. Currently only Conan is supported.

## Toolchain

A suite of tools for generating LLpkgs.

# Generation

## Directory structure

We design a whole new storage structure for llpkg store.

```
+ {LibraryName}
   |
   +--  {NormalGoPkgFiles}
   |    |
   |    +-- llpkg.cfg
   |    |
   |    +-- llcppg.cfg
   |
   +-- .llpkg
         |
         +-- llcppg.symb.json
         |
         +-- llcppg.pub

```

`llpkg.cfg` declares essential information for llgo module.

`llcppg.cfg` / `llcppg.symb.json` / `llcppg.pub` for customizing generation behavior in `llcppg` tool.

To indicate module's version, we follow Go's version management for nested module.

We tag `{LibraryName}/{Version}` for each `{LibraryName}` version.

For example
`libcjson/v1.7.18`

The advantage of this design is that it's fully compatible with native Go module.

Hence, it's simple to get llgo module using `go get` like

`go get github.com/goplus/llpkg/libcjson@v1.7.18`

## Reproducible Builds

A standardized methodology to generate compliant, reproducible, and controllable LLpkgs:

1. Retrieve binaries/headers from upstream and index them into a .pc file
2. Automatically generate LLpkg using the toolchain of a specific version
3. Debug and re-generate LLpkg by modifying the configuration file, and then publish

## Publication via GitHub Action

The recommended approach is to upload only configuration files and automate generation through GitHub Actions.

### Reason

- Direct user publication carries risks of post-generation malicious code insertion and review challenges.

### Workflow

1. After validating the configuration file llpkg.cfg & \*.symb.json (verifying its capability to generate LLpkgs automatically), create a PR to trigger a universal GitHub Action. This will generate the LLpkgs in different architectures and commit them to the PR.
2. Reviewers can verify and debug the generated LLpkg. Edits should be limited to llpkg.cfg & llcppg.symb.json, as other Go code is auto-generated and will be overwritten.
3. Once approved, merge the PR and publish the LLpkg. The commit should be tagged with `pkgname/semver`.

### Maintenance

All updates must be published as new versions with a -patchX suffix (X = integer).

Example: `1.0.0-1.1.7 → 1.0.0-1.1.7-patch1`

# Usage

`llgo get pkgname@version`  
(Where version corresponds to the original C library version)

Process:

1. Prepend `github.com/goplus/llpkg` address to pkgname and convert version according to specified rules
2. Use `go get` with the transformed address to download the LLpkg
3. Process configuration:

- Read `llpkg.cfg`
- Run `conan install` for binaries
- Activate environment variables for building (or use .pc file method)

# Details

## Version Conversion Rules

1. **Semver-compliant versions**: Use directly

   Example: 2.1.5 → 2.1.5

2. **Non-Semver versions**: Convert using pattern:

   `0.0.0-0-{original_version}`

   Conversion steps:

   1. Replace dots with hyphens: `2023.07.05` → `2023-07-05`

   2. Append `0-` prefix

   Examples:

   - `2023Q4 → 0.0.0-0-2023Q4`
   - `2023.07.05 → 0.0.0-0-2023-07-05`
   - `0067 → 0.0.0-0-0067`

## File Structure of llpkg.cfg

```json
{
  "package": {
    "name": "cjson",
    "version": "1.7.18"
  },
  "upstream": {
    "name": "conan",
    "config": {
      "generator": "cmake",
      "options": ""
    }
  },
  "toolchain": {
    "name": "llcppg",
    "version": "0.9.7",
    "config": {
      "trimPrefixes": []
    }
  }
}
```
